Path: news.gmane.org!not-for-mail
From: =?UTF-8?q?Amaury=20Decr=C3=AAme?= <amaury.decreme-Re5JQEeQqe8AvxtiuMwx3w@public.gmane.org>
Newsgroups: gmane.linux.drivers.i2c,gmane.linux.documentation,gmane.linux.kernel
Subject: [PATCH 2/2] I2C: SIS630: Cosmetics
Date: Mon,  6 Aug 2012 00:11:54 +0200
Lines: 576
Approved: news@gmane.org
Message-ID: <1344204714-16513-3-git-send-email-amaury.decreme@gmail.com>
References: <20120805140454.3e7a9606@endymion.delvare>
 <1344204714-16513-1-git-send-email-amaury.decreme@gmail.com>
NNTP-Posting-Host: plane.gmane.org
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: QUOTED-PRINTABLE
X-Trace: dough.gmane.org 1344204821 26426 80.91.229.3 (5 Aug 2012 22:13:41 GMT)
X-Complaints-To: usenet@dough.gmane.org
NNTP-Posting-Date: Sun, 5 Aug 2012 22:13:41 +0000 (UTC)
Cc: amalysh-S0/GAf8tV78@public.gmane.org, mhoffman-xQSgfq/1h4JiLUuM0BA3LQ@public.gmane.org, ralf-6z/3iImG2C8G8FEW9MqTrA@public.gmane.org,
	manuel.lauss-gM/Ye1E23mwN+BqQ9rBEUg@public.gmane.org, axel.lin-Re5JQEeQqe8AvxtiuMwx3w@public.gmane.org, olof-nZhT3qVonbNeoWH0uzbU5w@public.gmane.org,
	rusty-8n+1lVoiYb80n/F98K4Iww@public.gmane.org, linux-i2c-u79uwXL29TY76Z2rM5mHXA@public.gmane.org,
	linux-doc-u79uwXL29TY76Z2rM5mHXA@public.gmane.org, linux-kernel-u79uwXL29TY76Z2rM5mHXA@public.gmane.org,
	=?UTF-8?q?Amaury=20Decr=C3=AAme?= <amaury.decreme-Re5JQEeQqe8AvxtiuMwx3w@public.gmane.org>
To: khali-PUYAD+kWke1g9hUCZPvPmw@public.gmane.org, ben-linux-elnMNo+KYs3YtjvyW6yDsg@public.gmane.org, w.sang-bIcnvbaLZ9MEGnE8C9+IrQ@public.gmane.org,
	rob-VoJi6FS/r0vR7s880joybQ@public.gmane.org
Original-X-From: linux-i2c-owner-u79uwXL29TY76Z2rM5mHXA@public.gmane.org Mon Aug 06 00:13:38 2012
Return-path: <linux-i2c-owner-u79uwXL29TY76Z2rM5mHXA@public.gmane.org>
Envelope-to: gldi-i2c-1-wOFGN7rlS/M9smdsby/KFg@public.gmane.org
Original-Received: from vger.kernel.org ([209.132.180.67])
	by plane.gmane.org with esmtp (Exim 4.69)
	(envelope-from <linux-i2c-owner-u79uwXL29TY76Z2rM5mHXA@public.gmane.org>)
	id 1Sy94o-00005V-Dj
	for gldi-i2c-1-wOFGN7rlS/M9smdsby/KFg@public.gmane.org; Mon, 06 Aug 2012 00:13:34 +0200
Original-Received: (majordomo-u79uwXL29TY76Z2rM5mHXA@public.gmane.org) by vger.kernel.org via listexpand
	id S1755238Ab2HEWN2 convert rfc822-to-quoted-printable (ORCPT
	<rfc822;gldi-i2c-1@m.gmane.org>); Sun, 5 Aug 2012 18:13:28 -0400
Original-Received: from mail-wg0-f44.google.com ([74.125.82.44]:59761 "EHLO
	mail-wg0-f44.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755229Ab2HEWNB (ORCPT
	<rfc822;linux-i2c-u79uwXL29TY76Z2rM5mHXA@public.gmane.org>); Sun, 5 Aug 2012 18:13:01 -0400
Original-Received: by mail-wg0-f44.google.com with SMTP id dr13so2182630wgb.1
        for <multiple recipients>; Sun, 05 Aug 2012 15:13:00 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20120113;
        h=from:to:cc:subject:date:message-id:x-mailer:in-reply-to:references
         :mime-version:content-type:content-transfer-encoding;
        bh=pd+6ET97I7uhaOuoyFj67rPaZ/6wnUZmmcWB48/CSYs=;
        b=YC3q2mQC7w1/16/akloQ7OO9y2fJABjvlIyClb9SCDy4muXmje3GilgUF2grAuF6Qs
         3Zcr+038AV3rTwg7viTt5dSh0R93O+s+9sMJ2ts9SeC13bViQLmQ4pd4I2aOnqCi7PrZ
         OoA9vRIxIMCaiMSPeTznkO+ArjKcKW1cgaCmICsTgJOgV38koWQaSvuR4q3GqtuQttXq
         G7ooWE13aiXsAmqpfuSmB9caCSK5Z2UnLx7bP9MZ0838BKOaKf3YgQoe1NLG3JNK13VK
         EsEo2jexcAz4OE6B6FJSf7LsAe1eJWp6lx/6WTVJOYS0JfL4bjbaPbHXEGQ7DY3i52JD
         5OKg==
Original-Received: by 10.180.99.102 with SMTP id ep6mr13169938wib.7.1344204779978;
        Sun, 05 Aug 2012 15:12:59 -0700 (PDT)
Original-Received: from localhost.localdomain (val06-1-88-182-162-232.fbx.proxad.net. [88.182.162.232])
        by mx.google.com with ESMTPS id l5sm17756738wix.5.2012.08.05.15.12.57
        (version=TLSv1/SSLv3 cipher=OTHER);
        Sun, 05 Aug 2012 15:12:59 -0700 (PDT)
X-Mailer: git-send-email 1.7.8.6
In-Reply-To: <1344204714-16513-1-git-send-email-amaury.decreme-Re5JQEeQqe8AvxtiuMwx3w@public.gmane.org>
Original-Sender: linux-i2c-owner-u79uwXL29TY76Z2rM5mHXA@public.gmane.org
Precedence: bulk
List-ID: <linux-i2c.vger.kernel.org>
X-Mailing-List: linux-i2c-u79uwXL29TY76Z2rM5mHXA@public.gmane.org
Xref: news.gmane.org gmane.linux.drivers.i2c:12349 gmane.linux.documentation:6060 gmane.linux.kernel:1337925
Archived-At: <http://permalink.gmane.org/gmane.linux.kernel/1337925>

This patch replaces SMBus hex values by human readable constants and
correct some checkpatch -f errors.

Signed-off-by: Amaury Decr=C3=AAme <amaury.decreme-Re5JQEeQqe8AvxtiuMwx3w@public.gmane.org>
---
 drivers/i2c/busses/i2c-sis630.c |  311 ++++++++++++++++++++++---------=
--------
 1 files changed, 178 insertions(+), 133 deletions(-)

diff --git a/drivers/i2c/busses/i2c-sis630.c b/drivers/i2c/busses/i2c-s=
is630.c
index c950397..8dff4b9 100644
--- a/drivers/i2c/busses/i2c-sis630.c
+++ b/drivers/i2c/busses/i2c-sis630.c
@@ -19,7 +19,7 @@
 /*
    Changes:
    24.08.2002
-   	Fixed the typo in sis630_access (Thanks to Mark M. Hoffman)
+	Fixed the typo in sis630_access (Thanks to Mark M. Hoffman)
 	Changed sis630_transaction.(Thanks to Mark M. Hoffman)
    18.09.2002
 	Added SIS730 as supported.
@@ -82,6 +82,32 @@
 #define SMB_BYTE		0x08	/* ~0x8F data byte field */
 #define SMB_SAA			0x13	/* host slave alias address */
=20
+/* SMB_STS register */
+#define SMBALT_STS		0x80	/* Slave alert */
+#define BYTE_DONE_STS		0x10	/* Byte Done Status / Block Array */
+#define SMBMAS_STS		0x08	/* Host Master */
+#define SMBCOL_STS		0x04	/* Collision */
+#define SMBERR_STS		0x02	/* Device error */
+
+/* SMB_CNT register */
+#define MSTO_EN			0x40	/* Host Master Timeout Enable */
+#define SMBCLK_SEL		0x20	/* Host master clock selection */
+#define SMB_PROBE		0x02	/* Bus Probe */
+#define SMB_HOSTBUSY		0x01	/* Host Busy */
+
+/* SMBHOST_CNT register */
+#define SMB_KILL		0x20	/* Kill */
+#define SMB_START		0x10	/* Start */
+#define SMB_PTL			0x07	/* Command Protocol */
+
+/* SMB_ADDR register */
+#define SMB_ADDRESS		0xFE	/* Adress */
+#define SMB_RW			0x01	/* Read/Write */
+
+/* SMB_BYTE register */
+#define SMB_BYTE0		0xFF	/* Byte 0 */
+#define SMB_BYTE1		0xFF00	/* Byte 1 */
+
 /* register count for request_region
  * As we don't use SMB_PCOUNT, 20 is ok for SiS630 and SiS964
  */
@@ -136,23 +162,26 @@ static inline void sis630_write(u8 reg, u8 data)
 	outb(data, smbus_base + reg);
 }
=20
-static int sis630_transaction_start(struct i2c_adapter *adap, int size=
, u8 *oldclock)
+static int sis630_transaction_start(struct i2c_adapter *adap, int size=
,
+					u8 *oldclock)
 {
-        int temp;
+	int tmp;
=20
 	/* Make sure the SMBus host is ready to start transmitting. */
-	if ((temp =3D sis630_read(SMB_CNT) & 0x03) !=3D 0x00) {
-		dev_dbg(&adap->dev, "SMBus busy (%02x).Resetting...\n",temp);
+	tmp =3D sis630_read(SMB_CNT);
+	if ((tmp & (SMB_PROBE | SMB_HOSTBUSY)) !=3D 0x00) {
+		dev_dbg(&adap->dev, "SMBus busy (%02x). Resetting...\n", tmp);
 		/* kill smbus transaction */
-		sis630_write(SMBHOST_CNT, 0x20);
+		sis630_write(SMBHOST_CNT, SMB_KILL);
=20
-		if ((temp =3D sis630_read(SMB_CNT) & 0x03) !=3D 0x00) {
-			dev_dbg(&adap->dev, "Failed! (%02x)\n", temp);
+		tmp =3D sis630_read(SMB_CNT);
+		if (tmp & (SMB_PROBE | SMB_HOSTBUSY)) {
+			dev_dbg(&adap->dev, "Failed! (%02x)\n", tmp);
 			return -EBUSY;
-                } else {
+		} else {
 			dev_dbg(&adap->dev, "Successful!\n");
 		}
-        }
+	}
=20
 	/* save old clock, so we can prevent machine for hung */
 	*oldclock =3D sis630_read(SMB_CNT);
@@ -160,45 +189,46 @@ static int sis630_transaction_start(struct i2c_ad=
apter *adap, int size, u8 *oldc
 	dev_dbg(&adap->dev, "saved clock 0x%02x\n", *oldclock);
=20
 	if (clock_sel)
-		sis630_write(SMB_CNT, 0x20);
+		sis630_write(SMB_CNT, SMBCLK_SEL);
 	else
-		sis630_write(SMB_CNT, (*oldclock & ~0x40));
+		sis630_write(SMB_CNT, (*oldclock & ~MSTO_EN));
=20
 	/* clear all sticky bits */
-	temp =3D sis630_read(SMB_STS);
-	sis630_write(SMB_STS, temp & 0x1e);
+	tmp =3D sis630_read(SMB_STS);
+	sis630_write(SMB_STS, tmp & (BYTE_DONE_STS | SMBMAS_STS
+					| SMBCOL_STS | SMBERR_STS));
=20
 	/* start the transaction by setting bit 4 and size */
-	sis630_write(SMBHOST_CNT,0x10 | (size & 0x07));
+	sis630_write(SMBHOST_CNT, SMB_START | (size & SMB_PTL));
=20
 	return 0;
 }
=20
 static int sis630_transaction_wait(struct i2c_adapter *adap, int size)
 {
-	int temp, result =3D 0, timeout =3D 0;
+	int tmp, timeout =3D 0;
=20
 	/* We will always wait for a fraction of a second! */
 	do {
 		msleep(1);
-		temp =3D sis630_read(SMB_STS);
+		tmp =3D sis630_read(SMB_STS);
 		/* check if block transmitted */
-		if (size =3D=3D SIS630_BLOCK_DATA && (temp & 0x10))
-			break;
-	} while (!(temp & 0x0e) && (timeout++ < MAX_TIMEOUT));
+	} while (!(size =3D=3D SIS630_BLOCK_DATA && (tmp & BYTE_DONE_STS))
+		&& !(tmp & (SMBMAS_STS | SMBCOL_STS | SMBERR_STS))
+		&& (timeout++ < MAX_TIMEOUT));
=20
 	/* If the SMBus is still busy, we give up */
 	if (timeout > MAX_TIMEOUT) {
 		dev_dbg(&adap->dev, "SMBus Timeout!\n");
-		result =3D -ETIMEDOUT;
+		return -ETIMEDOUT;
 	}
=20
-	if (temp & 0x02) {
+	if (tmp & SMBERR_STS) {
 		dev_dbg(&adap->dev, "Error: Failed bus transaction\n");
-		result =3D -ENXIO;
+		return -ENXIO;
 	}
=20
-	if (temp & 0x04) {
+	if (tmp & SMBCOL_STS) {
 		dev_err(&adap->dev, "Bus collision!\n");
 		/* Datasheet:
 		 * SMBus Collision (SMBCOL_STS)
@@ -206,11 +236,11 @@ static int sis630_transaction_wait(struct i2c_ada=
pter *adap, int size)
 		 * SMBus Host loses in the bus arbitration. The software should
 		 * clear this bit and re-start SMBus operation.
 		 */
-		sis630_write(SMB_STS, temp & ~0x04);
+		sis630_write(SMB_STS, tmp & ~SMBCOL_STS);
 		return -EAGAIN;
 	}
=20
-	return result;
+	return 0;
 }
=20
 static void sis630_transaction_end(struct i2c_adapter *adap, u8 oldclo=
ck)
@@ -223,38 +253,41 @@ static void sis630_transaction_end(struct i2c_ada=
pter *adap, u8 oldclock)
 	 */
 	sis630_write(SMB_STS, 0xFF);
=20
-	dev_dbg(&adap->dev, "SMB_CNT before clock restore 0x%02x\n", sis630_r=
ead(SMB_CNT));
+	dev_dbg(&adap->dev, "SMB_CNT before clock restore 0x%02x\n",
+		sis630_read(SMB_CNT));
=20
-	if (clock_sel && !(oldclock & 0x20))
-		sis630_write(SMB_CNT,(sis630_read(SMB_CNT) & ~0x20));
+	if (clock_sel && !(oldclock & SMBCLK_SEL))
+		sis630_write(SMB_CNT, sis630_read(SMB_CNT) & ~SMBCLK_SEL);
=20
-	dev_dbg(&adap->dev, "SMB_CNT after clock restore 0x%02x\n", sis630_re=
ad(SMB_CNT));
+	dev_dbg(&adap->dev, "SMB_CNT after clock restore 0x%02x\n",
+		sis630_read(SMB_CNT));
 }
=20
 static int sis630_transaction(struct i2c_adapter *adap, int size)
 {
-	int result =3D 0;
+	int tmp;
 	int timeout =3D 0;
 	u8 oldclock =3D 0;
=20
 	/* We loop in case of collisions */
 	do {
-		result =3D sis630_transaction_start(adap, size, &oldclock);
-		if (!result) {
-			result =3D sis630_transaction_wait(adap, size);
+		tmp =3D sis630_transaction_start(adap, size, &oldclock);
+		if (!tmp) {
+			tmp =3D sis630_transaction_wait(adap, size);
 			sis630_transaction_end(adap, oldclock);
 		}
-	} while (result =3D=3D -EAGAIN && timeout++ < MAX_TIMEOUT);
+	} while (tmp =3D=3D -EAGAIN && timeout++ < MAX_TIMEOUT);
=20
 	if (timeout > MAX_TIMEOUT) {
 		dev_dbg(&adap->dev, "Too many collisions !\n");
 		return -ETIMEDOUT;
 	}
=20
-	return result;
+	return 0;
 }
=20
-static int sis630_block_data(struct i2c_adapter *adap, union i2c_smbus=
_data *data, int read_write)
+static int sis630_block_data(struct i2c_adapter *adap,
+				union i2c_smbus_data *data, int read_write)
 {
 	int i, len =3D 0, rc =3D 0;
 	u8 oldclock =3D 0;
@@ -266,39 +299,43 @@ static int sis630_block_data(struct i2c_adapter *=
adap, union i2c_smbus_data *dat
 		else if (len > 32)
 			len =3D 32;
 		sis630_write(SMB_COUNT, len);
-		for (i=3D1; i <=3D len; i++) {
-			dev_dbg(&adap->dev, "set data 0x%02x\n", data->block[i]);
+		for (i =3D 1; i <=3D len; i++) {
+			dev_dbg(&adap->dev, "set data 0x%02x\n",
+				data->block[i]);
 			/* set data */
 			sis630_write(SMB_BYTE+(i-1)%8, data->block[i]);
-			if (i=3D=3D8 || (len<8 && i=3D=3Dlen)) {
-				dev_dbg(&adap->dev, "start trans len=3D%d i=3D%d\n",len ,i);
+			if (i =3D=3D 8 || (len < 8 && i =3D=3D len)) {
+				dev_dbg(&adap->dev, "start trans len=3D%d i=3D%d\n",
+					len, i);
 				/* first transaction */
 				rc =3D sis630_transaction_start(adap,
 						SIS630_BLOCK_DATA, &oldclock);
 				if (rc)
 					return rc;
-			}
-			else if ((i-1)%8 =3D=3D 7 || i=3D=3Dlen) {
-				dev_dbg(&adap->dev, "trans_wait len=3D%d i=3D%d\n",len,i);
-				if (i>8) {
-					dev_dbg(&adap->dev, "clear smbary_sts len=3D%d i=3D%d\n",len,i);
+			} else if ((i-1)%8 =3D=3D 7 || i =3D=3D len) {
+				dev_dbg(&adap->dev, "trans_wait len=3D%d i=3D%d\n",
+					len, i);
+				if (i > 8) {
+					dev_dbg(&adap->dev,
+						"clr smbary_sts len=3D%d i=3D%d\n",
+						len, i);
 					/*
 					   If this is not first transaction,
 					   we must clear sticky bit.
 					   clear SMBARY_STS
 					*/
-					sis630_write(SMB_STS,0x10);
+					sis630_write(SMB_STS, BYTE_DONE_STS);
 				}
 				rc =3D sis630_transaction_wait(adap,
 						SIS630_BLOCK_DATA);
 				if (rc) {
-					dev_dbg(&adap->dev, "trans_wait failed\n");
+					dev_dbg(&adap->dev,
+						"trans_wait failed\n");
 					break;
 				}
 			}
 		}
-	}
-	else {
+	} else {
 		/* read request */
 		data->block[0] =3D len =3D 0;
 		rc =3D sis630_transaction_start(adap,
@@ -319,18 +356,21 @@ static int sis630_block_data(struct i2c_adapter *=
adap, union i2c_smbus_data *dat
 			if (data->block[0] > 32)
 				data->block[0] =3D 32;
=20
-			dev_dbg(&adap->dev, "block data read len=3D0x%x\n", data->block[0])=
;
+			dev_dbg(&adap->dev, "block data read len=3D0x%x\n",
+				data->block[0]);
=20
-			for (i=3D0; i < 8 && len < data->block[0]; i++,len++) {
-				dev_dbg(&adap->dev, "read i=3D%d len=3D%d\n", i, len);
+			for (i =3D 0; i < 8 && len < data->block[0]; i++, len++) {
+				dev_dbg(&adap->dev, "read i=3D%d len=3D%d\n", i,
+					len);
 				data->block[len+1] =3D sis630_read(SMB_BYTE+i);
 			}
=20
-			dev_dbg(&adap->dev, "clear smbary_sts len=3D%d i=3D%d\n",len,i);
+			dev_dbg(&adap->dev, "clear smbary_sts len=3D%d i=3D%d\n",
+				len, i);
=20
 			/* clear SMBARY_STS */
-			sis630_write(SMB_STS,0x10);
-		} while(len < data->block[0]);
+			sis630_write(SMB_STS, BYTE_DONE_STS);
+		} while (len < data->block[0]);
 	}
=20
 	sis630_transaction_end(adap, oldclock);
@@ -346,42 +386,48 @@ static s32 sis630_access(struct i2c_adapter *adap=
, u16 addr,
 	int status;
=20
 	switch (size) {
-		case I2C_SMBUS_QUICK:
-			sis630_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));
-			size =3D SIS630_QUICK;
-			break;
-		case I2C_SMBUS_BYTE:
-			sis630_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));
-			if (read_write =3D=3D I2C_SMBUS_WRITE)
-				sis630_write(SMB_CMD, command);
-			size =3D SIS630_BYTE;
-			break;
-		case I2C_SMBUS_BYTE_DATA:
-			sis630_write(SMB_ADDR, ((addr & 0x7f) << 1) | (read_write & 0x01));
-			sis630_write(SMB_CMD, command);
-			if (read_write =3D=3D I2C_SMBUS_WRITE)
-				sis630_write(SMB_BYTE, data->byte);
-			size =3D SIS630_BYTE_DATA;
-			break;
-		case I2C_SMBUS_PROC_CALL:
-		case I2C_SMBUS_WORD_DATA:
-			sis630_write(SMB_ADDR,((addr & 0x7f) << 1) | (read_write & 0x01));
-			sis630_write(SMB_CMD, command);
-			if (read_write =3D=3D I2C_SMBUS_WRITE) {
-				sis630_write(SMB_BYTE, data->word & 0xff);
-				sis630_write(SMB_BYTE + 1,(data->word & 0xff00) >> 8);
-			}
-			size =3D (size =3D=3D I2C_SMBUS_PROC_CALL ? SIS630_PCALL : SIS630_W=
ORD_DATA);
-			break;
-		case I2C_SMBUS_BLOCK_DATA:
-			sis630_write(SMB_ADDR,((addr & 0x7f) << 1) | (read_write & 0x01));
+	case I2C_SMBUS_QUICK:
+		sis630_write(SMB_ADDR, ((addr << 1) & SMB_ADDRESS) |
+							(read_write & SMB_RW));
+		size =3D SIS630_QUICK;
+		break;
+	case I2C_SMBUS_BYTE:
+		sis630_write(SMB_ADDR, ((addr << 1) & SMB_ADDRESS) |
+							(read_write & SMB_RW));
+		if (read_write =3D=3D I2C_SMBUS_WRITE)
 			sis630_write(SMB_CMD, command);
-			size =3D SIS630_BLOCK_DATA;
-			return sis630_block_data(adap, data, read_write);
-		default:
-			dev_warn(&adap->dev, "Unsupported transaction %d\n",
-				 size);
-			return -EOPNOTSUPP;
+		size =3D SIS630_BYTE;
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		sis630_write(SMB_ADDR, ((addr << 1) & SMB_ADDRESS) |
+							(read_write & SMB_RW));
+		sis630_write(SMB_CMD, command);
+		if (read_write =3D=3D I2C_SMBUS_WRITE)
+			sis630_write(SMB_BYTE, data->byte);
+		size =3D SIS630_BYTE_DATA;
+		break;
+	case I2C_SMBUS_PROC_CALL:
+	case I2C_SMBUS_WORD_DATA:
+		sis630_write(SMB_ADDR, ((addr << 1) & SMB_ADDRESS) |
+							(read_write & SMB_RW));
+		sis630_write(SMB_CMD, command);
+		if (read_write =3D=3D I2C_SMBUS_WRITE) {
+			sis630_write(SMB_BYTE, data->word & SMB_BYTE0);
+			sis630_write(SMB_BYTE + 1,
+						(data->word & SMB_BYTE1) >> 8);
+		}
+		size =3D (size =3D=3D I2C_SMBUS_PROC_CALL ?
+				SIS630_PCALL : SIS630_WORD_DATA);
+		break;
+	case I2C_SMBUS_BLOCK_DATA:
+		sis630_write(SMB_ADDR, ((addr << 1) & SMB_ADDRESS) |
+							(read_write & SMB_RW));
+		sis630_write(SMB_CMD, command);
+		size =3D SIS630_BLOCK_DATA;
+		return sis630_block_data(adap, data, read_write);
+	default:
+		dev_warn(&adap->dev, "Unsupported transaction %d\n", size);
+		return -EOPNOTSUPP;
 	}
=20
 	status =3D sis630_transaction(adap, size);
@@ -393,15 +439,16 @@ static s32 sis630_access(struct i2c_adapter *adap=
, u16 addr,
 		return 0;
 	}
=20
-	switch(size) {
-		case SIS630_BYTE:
-		case SIS630_BYTE_DATA:
-			data->byte =3D sis630_read(SMB_BYTE);
-			break;
-		case SIS630_PCALL:
-		case SIS630_WORD_DATA:
-			data->word =3D sis630_read(SMB_BYTE) + (sis630_read(SMB_BYTE + 1) <=
< 8);
-			break;
+	switch (size) {
+	case SIS630_BYTE:
+	case SIS630_BYTE_DATA:
+		data->byte =3D sis630_read(SMB_BYTE);
+		break;
+	case SIS630_PCALL:
+	case SIS630_WORD_DATA:
+		data->word =3D sis630_read(SMB_BYTE) +
+				(sis630_read(SMB_BYTE + 1) << 8);
+		break;
 	}
=20
 	return 0;
@@ -409,9 +456,9 @@ static s32 sis630_access(struct i2c_adapter *adap, =
u16 addr,
=20
 static u32 sis630_func(struct i2c_adapter *adapter)
 {
-	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BY=
TE_DATA |
-		I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_PROC_CALL |
-		I2C_FUNC_SMBUS_BLOCK_DATA;
+	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_PROC_CALL | I2C_FUNC_SMBUS_BLOCK_DATA;
 }
=20
 static int __devinit sis630_setup(struct pci_dev *sis630_dev)
@@ -423,19 +470,19 @@ static int __devinit sis630_setup(struct pci_dev =
*sis630_dev)
 	static unsigned short acpi_base;
=20
 	/* check for supported SiS devices */
-	for (i=3D0; supported[i] > 0 ; i++) {
-		if ((dummy =3D pci_get_device(PCI_VENDOR_ID_SI, supported[i], dummy)=
))
+	for (i =3D 0; supported[i] > 0; i++) {
+		dummy =3D pci_get_device(PCI_VENDOR_ID_SI, supported[i], dummy);
+		if (dummy)
 			break; /* found */
 	}
=20
 	if (dummy) {
 		pci_dev_put(dummy);
-	}
-        else if (force) {
-		dev_err(&sis630_dev->dev, "WARNING: Can't detect SIS630 compatible d=
evice, but "
+	} else if (force) {
+		dev_err(&sis630_dev->dev,
+			"WARNING: Can't detect SIS630 compatible device, but "
 			"loading because of force option enabled\n");
- 	}
-	else {
+	} else {
 		return -ENODEV;
 	}
=20
@@ -443,24 +490,23 @@ static int __devinit sis630_setup(struct pci_dev =
*sis630_dev)
 	   Enable ACPI first , so we can accsess reg 74-75
 	   in acpi io space and read acpi base addr
 	*/
-	if (pci_read_config_byte(sis630_dev, SIS630_BIOS_CTL_REG,&b)) {
+	if (pci_read_config_byte(sis630_dev, SIS630_BIOS_CTL_REG, &b)) {
 		dev_err(&sis630_dev->dev, "Error: Can't read bios ctl reg\n");
-		retval =3D -ENODEV;
-		goto exit;
+		return -ENODEV;
 	}
 	/* if ACPI already enabled , do nothing */
 	if (!(b & 0x80) &&
 	    pci_write_config_byte(sis630_dev, SIS630_BIOS_CTL_REG, b | 0x80))=
 {
 		dev_err(&sis630_dev->dev, "Error: Can't enable ACPI\n");
-		retval =3D -ENODEV;
-		goto exit;
+		return -ENODEV;
 	}
=20
 	/* Determine the ACPI base address */
-	if (pci_read_config_word(sis630_dev,SIS630_ACPI_BASE_REG,&acpi_base))=
 {
-		dev_err(&sis630_dev->dev, "Error: Can't determine ACPI base address\=
n");
-		retval =3D -ENODEV;
-		goto exit;
+	if (pci_read_config_word(sis630_dev, SIS630_ACPI_BASE_REG,
+								&acpi_base)) {
+		dev_err(&sis630_dev->dev,
+				"Error: Can't determine ACPI base address\n");
+		return -ENODEV;
 	}
=20
 	dev_dbg(&sis630_dev->dev, "ACPI base at 0x%04x\n", acpi_base);
@@ -474,8 +520,10 @@ static int __devinit sis630_setup(struct pci_dev *=
sis630_dev)
=20
 	retval =3D acpi_check_region(smbus_base + SMB_STS, SIS630_SMB_IOREGIO=
N,
 				   sis630_driver.name);
-	if (retval)
-		goto exit;
+	if (retval) {
+		smbus_base =3D 0;
+		return retval;
+	}
=20
 	/* Everything is happy, let's grab the memory and set things up. */
 	if (!request_region(smbus_base + SMB_STS, SIS630_SMB_IOREGION,
@@ -483,16 +531,10 @@ static int __devinit sis630_setup(struct pci_dev =
*sis630_dev)
 		dev_err(&sis630_dev->dev,
 			"SMBus registers 0x%04x-0x%04x already in use!\n",
 			smbus_base + SMB_STS, smbus_base + SMB_SAA);
-		retval =3D -EBUSY;
-		goto exit;
+		return -EBUSY;
 	}
=20
-	retval =3D 0;
-
-exit:
-	if (retval)
-		smbus_base =3D 0;
-	return retval;
+	return 0;
 }
=20
=20
@@ -511,15 +553,18 @@ static DEFINE_PCI_DEVICE_TABLE(sis630_ids) =3D {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_503) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_964) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_LPC) },
-	{ 0, }
+	{ 0 }
 };
=20
-MODULE_DEVICE_TABLE (pci, sis630_ids);
+MODULE_DEVICE_TABLE(pci, sis630_ids);
=20
-static int __devinit sis630_probe(struct pci_dev *dev, const struct pc=
i_device_id *id)
+static int __devinit sis630_probe(struct pci_dev *dev,
+					const struct pci_device_id *id)
 {
 	if (sis630_setup(dev)) {
-		dev_err(&dev->dev, "SIS630 comp. bus not detected, module not insert=
ed.\n");
+		dev_err(&dev->dev,
+			"SIS630 compatible bus not detected, "
+			"module not inserted.\n");
 		return -ENODEV;
 	}
=20
--=20
1.7.8.6

