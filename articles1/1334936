Path: news.gmane.org!not-for-mail
From: Thierry Reding <thierry.reding-RM9K5IK7kjKj5M59NBduVrNAH6kLmebB@public.gmane.org>
Newsgroups: gmane.linux.drivers.devicetree,gmane.linux.kernel
Subject: Re: [PATCH v2] gpio: Add Avionic Design N-bit GPIO expander support
Date: Mon, 30 Jul 2012 09:47:14 +0200
Lines: 668
Approved: news@gmane.org
Message-ID: <20120730074714.GC15245@avionic-0098.mockup.avionic-design.de>
References: <1343044770-6591-1-git-send-email-thierry.reding@avionic-design.de>
 <CACRpkdaZcUvcJMUZTqCEU5FQYhE3EvSSfUEnEx0dYRt-6x5Nig@mail.gmail.com>
NNTP-Posting-Host: plane.gmane.org
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary="===============5012077910755583720=="
X-Trace: dough.gmane.org 1343634458 9445 80.91.229.3 (30 Jul 2012 07:47:38 GMT)
X-Complaints-To: usenet@dough.gmane.org
NNTP-Posting-Date: Mon, 30 Jul 2012 07:47:38 +0000 (UTC)
Cc: Linus Walleij <linus.walleij-0IS4wlFg1OjSUeElwK9/Pw@public.gmane.org>,
 devicetree-discuss-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org, linux-kernel-u79uwXL29TY76Z2rM5mHXA@public.gmane.org,
 Rob Herring <rob.herring-bsGFqQB8/DxBDgjK7y7TUQ@public.gmane.org>, Wolfram Sang <w.sang-bIcnvbaLZ9MEGnE8C9+IrQ@public.gmane.org>
To: Linus Walleij <linus.walleij-QSEj5FYQhm4dnm+yROfE0A@public.gmane.org>
Original-X-From: devicetree-discuss-bounces+gldd-devicetree-discuss=m.gmane.org-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org Mon Jul 30 09:47:35 2012
Return-path: <devicetree-discuss-bounces+gldd-devicetree-discuss=m.gmane.org-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org>
Envelope-to: gldd-devicetree-discuss@m.gmane.org
Original-Received: from ozlabs.org ([203.10.76.45])
	by plane.gmane.org with esmtp (Exim 4.69)
	(envelope-from <devicetree-discuss-bounces+gldd-devicetree-discuss=m.gmane.org-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org>)
	id 1SvkhS-00066b-1Z
	for gldd-devicetree-discuss@m.gmane.org; Mon, 30 Jul 2012 09:47:35 +0200
Original-Received: from ozlabs.org (localhost [IPv6:::1])
	by ozlabs.org (Postfix) with ESMTP id 698E02C00C9
	for <gldd-devicetree-discuss@m.gmane.org>; Mon, 30 Jul 2012 17:47:32 +1000 (EST)
Original-Received: from moutng.kundenserver.de (moutng.kundenserver.de
 [212.227.126.186]) by ozlabs.org (Postfix) with ESMTP id 4EDE42C0079
 for <devicetree-discuss-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org>;
 Mon, 30 Jul 2012 17:47:23 +1000 (EST)
Original-Received: from mailbox.adnet.avionic-design.de (mailbox.avionic-design.de
 [109.75.18.3])
 by mrelayeu.kundenserver.de (node=mrbap0) with ESMTP (Nemesis)
 id 0M34kR-1TlNbs0GMp-00svoY; Mon, 30 Jul 2012 09:47:19 +0200
Original-Received: from localhost (localhost [127.0.0.1])
 by mailbox.adnet.avionic-design.de (Postfix) with ESMTP id 5893A2A282E6;
 Mon, 30 Jul 2012 09:47:17 +0200 (CEST)
X-Virus-Scanned: amavisd-new at avionic-design.de
Original-Received: from mailbox.adnet.avionic-design.de ([127.0.0.1])
 by localhost (mailbox.avionic-design.de [127.0.0.1]) (amavisd-new, port 10024)
 with ESMTP id 0V4dlv+a2s8g; Mon, 30 Jul 2012 09:47:15 +0200 (CEST)
Original-Received: from localhost (avionic-0098.adnet.avionic-design.de [172.20.31.233])
 (Authenticated sender: thierry.reding)
 by mailbox.adnet.avionic-design.de (Postfix) with ESMTPA id 1886A2A281DE;
 Mon, 30 Jul 2012 09:47:15 +0200 (CEST)
In-Reply-To: <CACRpkdaZcUvcJMUZTqCEU5FQYhE3EvSSfUEnEx0dYRt-6x5Nig-JsoAwUIsXosN+BqQ9rBEUg@public.gmane.org>
User-Agent: Mutt/1.5.21 (2010-09-15)
X-Provags-ID: V02:K0:42RxZoEI8uBypEFWQDBnbvbSP4lbUVfmVoB2ZabgqkG
 j0HYvPpzS5Gea4xfb3+Y09xEKBaDhFTUMPAcsAg9FhN1M1bWMF
 VyGl05Mqz86cl3YPToJ2gck04E88riH5nM0WhGrmYd4uaaDNaF
 NJUBY2saROryEMMzqI6+kwgCZogZqcb5TwrqPKiaD4Km9Nh09S
 kHw5uWZEx8UzsPX2v4pon5DzsC4CWijFfcXjaGoMzasGouAYBd
 sToYb+fCYhouITKTO2gG7Jd8lA0iDj0jswcyy7u6cVx2wFJqrQ
 5im6DNagixZ72wasJ51f6l4+4m4PFuujw8oCq3JTfuH8iPFKlK
 WPXNiy1YWHh1KxNbV03N3exQXblnosmWp0ctyESgXX4pXrR8CQ
 CtSpraUIGfzbktHUcDmJ2c5jpAf1CIsiTr17d1MzUbzU5W9K/M eV5Vm
X-BeenThere: devicetree-discuss-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org
X-Mailman-Version: 2.1.15
Precedence: list
List-Id: Discussion about Device Trees and associated tools across all
 architectures <devicetree-discuss.lists.ozlabs.org>
List-Unsubscribe: <https://lists.ozlabs.org/options/devicetree-discuss>,
 <mailto:devicetree-discuss-request-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org?subject=unsubscribe>
List-Archive: <http://lists.ozlabs.org/pipermail/devicetree-discuss/>
List-Post: <mailto:devicetree-discuss-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org>
List-Help: <mailto:devicetree-discuss-request-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org?subject=help>
List-Subscribe: <https://lists.ozlabs.org/listinfo/devicetree-discuss>,
 <mailto:devicetree-discuss-request-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org?subject=subscribe>
Errors-To: devicetree-discuss-bounces+gldd-devicetree-discuss=m.gmane.org-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org
Original-Sender: "devicetree-discuss"
 <devicetree-discuss-bounces+gldd-devicetree-discuss=m.gmane.org-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org>
Xref: news.gmane.org gmane.linux.drivers.devicetree:18748 gmane.linux.kernel:1334936
Archived-At: <http://permalink.gmane.org/gmane.linux.kernel/1334936>


--===============5012077910755583720==
Content-Type: multipart/signed; micalg=pgp-sha1;
	protocol="application/pgp-signature"; boundary="5QAgd0e35j3NYeGe"
Content-Disposition: inline


--5QAgd0e35j3NYeGe
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On Sun, Jul 29, 2012 at 07:13:57PM +0200, Linus Walleij wrote:
> On Mon, Jul 23, 2012 at 1:59 PM, Thierry Reding
> <thierry.reding-RM9K5IK7kjKj5M59NBduVrNAH6kLmebB@public.gmane.org> wrote:
>=20
> > This commit adds a driver for the Avionic Design N-bit GPIO expander.
> > The expander provides a variable number of GPIO pins with interrupt
> > support.
> (...)
> > diff --git a/Documentation/devicetree/bindings/gpio/gpio-adnp.txt b/Doc=
umentation/devicetree/bindings/gpio/gpio-adnp.txt
> > new file mode 100644
> > index 0000000..513a18e
> > --- /dev/null
> > +++ b/Documentation/devicetree/bindings/gpio/gpio-adnp.txt
> > @@ -0,0 +1,38 @@
> > +Avionic Design N-bit GPIO expander bindings
> > +
> > +Required properties:
> > +- compatible: should be "ad,gpio-adnp"
> > +- reg: The I2C slave address for this device.
> > +- interrupt-parent: phandle of the parent interrupt controller.
> > +- interrupts: Interrupt specifier for the controllers interrupt.
> > +- #gpio-cells: Should be 2. The first cell is the GPIO number and the
> > +  second cell is used to specify optional parameters:
> > +  - bit 0: polarity (0: normal, 1: inverted)
> > +- gpio-controller: Marks the device as a GPIO controller
> > +- #interrupt-cells: Should be 2. The first cell contains the GPIO numb=
er,
> > +  whereas the second cell is used to specify flags:
> > +    bits[3:0] trigger type and level flags
> > +      1 =3D low-to-high edge triggered
> > +      2 =3D high-to-low edge triggered
> > +      4 =3D active high level-sensitive
> > +      8 =3D active low level-sensitive
>=20
> Why on earth would a bunch of flags be an "interrupt cell"?
>=20
> Maybe there is something about DT bindings I don't get so
> please educate me.
>=20
> I can see that OMAP is doing this, but is it a good idea?
> I really need Rob/Grant to comment on this.
>=20
> > +- interrupt-controller: Marks the device as an interrupt controller.
> > +- nr-gpios: The number of pins supported by the controller.
>=20
> These two last things look very generic, like something every GPIO
> driver could want to expose.

As Arnd mentioned, interrupt-controller is a generic property required
by all interrupt controller nodes. Perhaps it shouldn't be listed in the
DT binding for this driver.

As to the nr-gpios property, this is actually not only for informational
purposes, but it also allows the driver to be configured to handle any
number of bits (powers of two). However since this is also a description
of the hardware it may be useful to make this into a generic property
for GPIO controllers.

> I'd really like to have Grant's word on GPIO DT bindings and how these
> should look, I had some discussion with Wolfram (the I2C maintainer)
> about bindings turning out less generic than they ought to be, so we
> need some discussion on this.
>=20
> Arnd recently consolidated some MMC props, maybe we need to do
> the same for GPIO drivers.
>=20
> (...)
> > diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
> > index 502b5ea..d1b0f7d 100644
> > --- a/drivers/gpio/Kconfig
> > +++ b/drivers/gpio/Kconfig
> > @@ -444,6 +444,24 @@ config GPIO_ADP5588_IRQ
> >           Say yes here to enable the adp5588 to be used as an interrupt
> >           controller. It requires the driver to be built in the kernel.
> >
> > +config GPIO_ADNP
> > +       tristate "Avionic Design N-bit GPIO expander"
> > +       depends on I2C && OF
> > +       help
> > +         This option enables support for N GPIOs found on Avionic Desi=
gn
> > +         I2C GPIO expanders. The register space will be extended by po=
wers
> > +         of two, so the controller will need to accomodate for that. F=
or
> > +         example: if a controller provides 48 pins, 6 registers will be
> > +         enough to represent all pins, but the driver will assume a
> > +         register layout for 64 pins (8 registers).
> > +
> > +config GPIO_ADNP_IRQ
> > +       tristate "Interrupt controller support"
> > +       depends on GPIO_ADNP
> > +       help
> > +         Say yes here to enable the Avionic Design N-bit GPIO expander=
 to
> > +         be used as an interrupt controller.
>=20
> First: please describe the usecase where the Avionic driver is used
> without making use of the IRQ, and *why* it should be possible
> to configure this out. E.g. is there a hardware which isn't using the
> IRQ portions? If there is no non-irq usecase just drop this
> config option.

This expander is used in a number of Tegra-based boards and handles
things like enabling or disabling power to a given IC but on other
boards it is also used to handle interrupts from input devices or
card-detect for example.

The controller is synthesized in a CPLD, which is one of the reasons for
the nr-gpios DT property. There is at least one platform that currently
doesn't use the interrupt functionality. Mainly I allowed this to be
configured out in order to reduce the number of interrupts required for
a platform. Another reason was that at the time I first wrote this, IRQ
domains hadn't been available, so the driver couldn't be built as a
module if interrupt support was required. This also no longer applies.

I'm actually fine either way, but I thought it'd be most flexible by
keeping the IRQ support optional for the above reasons.

> If you're keeping it:
>=20
> Now this is going to appear as a single line under the ADNP driver
> config entry saying "Interrupt controller support", which is too
> generic.
>=20
> Please make it expand to a submenu so that it gets indented below the
> controller driver.
>=20
> (...)
> > diff --git a/drivers/gpio/gpio-adnp.c b/drivers/gpio/gpio-adnp.c
> > new file mode 100644
> > index 0000000..c122ff4
> > --- /dev/null
> > +++ b/drivers/gpio/gpio-adnp.c
> > @@ -0,0 +1,615 @@
> > +/*
> > + * Copyright (C) 2011-2012 Avionic Design GmbH
> > + *
> > + * This program is free software; you can redistribute it and/or modify
> > + * it under the terms of the GNU General Public License version 2 as
> > + * published by the Free Software Foundation.
> > + */
> > +
> > +#include <linux/gpio.h>
> > +#include <linux/i2c.h>
> > +#include <linux/interrupt.h>
> > +#include <linux/irqdomain.h>
>=20
> Good!
>=20
> > +#include <linux/module.h>
> > +#include <linux/of_irq.h>
> > +#include <linux/seq_file.h>
> > +#include <linux/slab.h>
> > +
> > +#define GPIO_DDR(gpio) (0x00 << (gpio)->reg_shift)
> > +#define GPIO_PLR(gpio) (0x01 << (gpio)->reg_shift)
> > +#define GPIO_IER(gpio) (0x02 << (gpio)->reg_shift)
> > +#define GPIO_ISR(gpio) (0x03 << (gpio)->reg_shift)
> > +#define GPIO_PTR(gpio) (0x04 << (gpio)->reg_shift)
> > +
> > +struct adnp {
> > +       struct i2c_client *client;
> > +       struct gpio_chip gpio;
> > +       unsigned int reg_shift;
> > +
> > +       struct mutex i2c_lock;
> > +
> > +       struct irq_domain *domain;
> > +       struct mutex irq_lock;
> > +
> > +       u8 *irq_mask;
> > +       u8 *irq_mask_cur;
> > +       u8 *irq_level;
> > +       u8 *irq_rise;
> > +       u8 *irq_fall;
> > +       u8 *irq_high;
> > +       u8 *irq_low;
>=20
> Some or all of this looks like a regmap reimplementation, see below.

Actually none of these represent actual registers, except for irq_mask
and irq_mask_cur. They are used to emulate various IRQ trigger modes.

>=20
> > +};
> > +
> > +static int adnp_read(struct adnp *gpio, unsigned offset, uint8_t *valu=
e)
>=20
> I don't know why you name the struct adnp variable "gpio" everywhere,
> that is quite ambigous. Why not name this variable "adnp" consequently
> everywhere?

I can change that, no problem.

> > +{
> > +       int err;
> > +
> > +       err =3D i2c_smbus_read_byte_data(gpio->client, offset);
> > +       if (err < 0) {
> > +               dev_err(gpio->gpio.dev, "%s failed: %d\n",
> > +                       "i2c_smbus_read_byte_data()", err);
> > +               return err;
> > +       }
> > +
> > +       *value =3D err;
> > +       return 0;
> > +}
> > +
> > +static int adnp_write(struct adnp *gpio, unsigned offset, uint8_t valu=
e)
> > +{
> > +       int err;
> > +
> > +       err =3D i2c_smbus_write_byte_data(gpio->client, offset, value);
> > +       if (err < 0) {
> > +               dev_err(gpio->gpio.dev, "%s failed: %d\n",
> > +                       "i2c_smbus_write_byte_data()", err);
> > +               return err;
> > +       }
> > +
> > +       return 0;
> > +}
> > +
> > +static int adnp_gpio_get(struct gpio_chip *chip, unsigned offset)
> > +{
> > +       struct adnp *gpio =3D container_of(chip, struct adnp, gpio);
>=20
> When I do this at several places in a driver I usually define
> a macro like
>=20
> #define to_adnp(foo) container_of(foo, struct adnp, gpio)
>=20
> Used like so:
>=20
> struct adnp *adnp =3D to_adnp(chip);

Yes, I usually do that as well. I guess this driver has been in the
works in too many variants for too long. =3D)

>=20
> > +       unsigned int reg =3D offset >> gpio->reg_shift;
> > +       unsigned int pos =3D offset & 7;
> > +       u8 value;
> > +       int err;
> > +
> > +       mutex_lock(&gpio->i2c_lock);
>=20
> The point of taking this mutex here avoids me.
> adnp_read() only performs a single transaction.

I think that's a relic from an earlier version that used to access the
PTR (Pin Tristate Register) as well. At the time I used to return 2 here
to signify a tristated input, which was dependent on the contents of the
PTR. Tristating an output is, I believe, better done using pinmux/
pinctrl nowadays, so I took that code because the only platform where
this was ever used will probably never be mainlined.

On that note, provided there is special additional circuitry, the GPIO
controller is able to detect tristate on an input. I'm not aware that
the pinctrl subsystem provides for that functionality yet, right?

> > +static void adnp_gpio_dbg_show(struct seq_file *s, struct gpio_chip *c=
hip)
> > +{
> > +       struct adnp *gpio =3D container_of(chip, struct adnp, gpio);
> > +       u8 *base, *ddr, *plr, *ier, *isr, *ptr;
> > +       unsigned int regs, i, j;
> > +       int err;
> > +
> > +       regs =3D 1 << gpio->reg_shift;
> > +
> > +       base =3D kzalloc(regs * 5, GFP_KERNEL);
>=20
> Why kzalloc()/kfree() when you can just use a
>=20
> static u8 base[N];
>=20
> where N is the max number of registers on any HW instead?

As I explained above, the number of pins is configurable, so it'd be
quite a waste to always assume a maximum of, say, 256 pins if the
hardware actually only uses 8.

> > +       if (!base)
> > +               return;
> > +
> > +       ddr =3D base + (regs * 0);
> > +       plr =3D base + (regs * 1);
> > +       ier =3D base + (regs * 2);
> > +       isr =3D base + (regs * 3);
> > +       ptr =3D base + (regs * 4);
> > +
> > +       for (i =3D 0; i < regs; i++) {
> > +               err =3D adnp_read(gpio, GPIO_DDR(gpio) + i, &ddr[i]);
> > +               if (err < 0)
> > +                       goto out;
> > +
> > +               err =3D adnp_read(gpio, GPIO_PLR(gpio) + i, &plr[i]);
> > +               if (err < 0)
> > +                       goto out;
> > +
> > +               err =3D adnp_read(gpio, GPIO_IER(gpio) + i, &ier[i]);
> > +               if (err < 0)
> > +                       goto out;
> > +
> > +               err =3D adnp_read(gpio, GPIO_ISR(gpio) + i, &isr[i]);
> > +               if (err < 0)
> > +                       goto out;
> > +
> > +               err =3D adnp_read(gpio, GPIO_PTR(gpio) + i, &ptr[i]);
> > +               if (err < 0)
> > +                       goto out;
> > +       }
>=20
> You must take the mutex around this for-loop, don't you?
>=20
> Else browing debugfs will sporadically corrupt transfers,
> or something like that. Or was this intended to cut into any
> ongoing transfer couple?

No, you're right. This should be protected by the mutex.

> > +       for (i =3D 0; i < regs; i++) {
> > +               for (j =3D 0; j < 8; j++) {
> > +                       unsigned int bit =3D (i << gpio->reg_shift) + j;
> > +                       const char *direction =3D "input ";
> > +                       const char *level =3D "low ";
> > +                       const char *interrupt =3D "disabled";
> > +                       const char *pending =3D "";
> > +
> > +                       if (ddr[i] & BIT(j))
> > +                               direction =3D "output";
> > +
> > +                       if (plr[i] & BIT(j))
> > +                               level =3D "high";
> > +
> > +                       if (ier[i] & BIT(j))
> > +                               interrupt =3D "enabled ";
> > +
> > +                       if (isr[i] & BIT(j))
> > +                               pending =3D "pending";
> > +
> > +                       seq_printf(s, "%2u: %s %s IRQ %s %s\n", bit,
> > +                                  direction, level, interrupt, pending=
);
> > +               }
> > +       }
> > +
> > +out:
> > +       kfree(base);
> > +}
> > +
> > +static int adnp_gpio_setup(struct adnp *gpio, unsigned int num_gpios)
> > +{
> > +       struct gpio_chip *chip =3D &gpio->gpio;
> > +
> > +       gpio->reg_shift =3D get_count_order(num_gpios) - 3;
> > +
> > +       chip->direction_input =3D adnp_gpio_direction_input;
> > +       chip->direction_output =3D adnp_gpio_direction_output;
> > +       chip->get =3D adnp_gpio_get;
> > +       chip->set =3D adnp_gpio_set;
> > +       chip->can_sleep =3D 1;
> > +       if (IS_ENABLED(CONFIG_DEBUG_FS))
> > +               chip->dbg_show =3D adnp_gpio_dbg_show;
> > +
> > +       chip->base =3D -1;
> > +       chip->ngpio =3D num_gpios;
> > +       chip->label =3D gpio->client->name;
> > +       chip->dev =3D &gpio->client->dev;
> > +       chip->of_node =3D chip->dev->of_node;
> > +       chip->owner =3D THIS_MODULE;
>=20
> Usually we define the struct gpio_chip as a static const and have
> the state containter hold a static const struct gpio_chip *chip;
> entry assigned to point to the static const at probe time.

The problem with a static const is that you can no longer configure the
number of GPIOs at runtime, which is sort of essential for this driver.

> All other GPIO drivers #ifdef their debugfs code, this probably
> works fine too, but never saw it before.
>=20
> I'm ambivalent about this, I sort of like it because it avoids
> #ifdefs and also makes sure the code is always compiled,
> so if you like it like this, keep it.

I've started to use this wherever possible because otherwise you have to
build numerous configurations to ensure complete compile coverage. Then
again this also has the drawback to potentially hide issues if you don't
properly separate conditionalized code.

> (...)
> > +static void adnp_irq_update_mask(struct adnp *gpio)
> > +{
> > +       unsigned int regs =3D 1 << gpio->reg_shift;
> > +       bool equal =3D true;
> > +       unsigned int i;
> > +
> > +       for (i =3D 0; i < regs; i++) {
> > +               if (gpio->irq_mask[i] !=3D gpio->irq_mask_cur[i]) {
> > +                       equal =3D false;
> > +                       break;
> > +               }
> > +       }
>=20
> This is not looking good. It looks like you're reimplementing
> parts of regmap.
>=20
> In that case, please use <linux/regmap.h> to cache registers
> instead.
>=20
> But I'm not sure ...
>=20
> (...)
> > +static void adnp_irq_bus_lock(struct irq_data *data)
> > +{
> > +       struct adnp *gpio =3D irq_data_get_irq_chip_data(data);
> > +       unsigned int regs =3D 1 << gpio->reg_shift;
> > +
> > +       mutex_lock(&gpio->irq_lock);
> > +       memcpy(gpio->irq_mask_cur, gpio->irq_mask, regs);
> > +}
> > +
> > +static void adnp_irq_bus_unlock(struct irq_data *data)
> > +{
> > +       struct adnp *gpio =3D irq_data_get_irq_chip_data(data);
> > +
> > +       adnp_irq_update_mask(gpio);
> > +       mutex_unlock(&gpio->irq_lock);
> > +}
>=20
> Actually I'm not following why the IRQ mask registers are shadowed
> at bus_lock and restored at bus_unlock().
>=20
> A comment describing why that's needed and how it works is
> definately needed.

I'm not sure that this is required anymore. IIRC I did copy this from
some other driver at the time. This is probably supposed to be an
optimization, but I think I can live without it.

>=20
> (...)
> > +static const struct irq_domain_ops adnp_irq_domain_ops =3D {
> > +       .map =3D adnp_irq_map,
> > +       .xlate =3D irq_domain_xlate_twocell,
> > +};
> > +
> > +static int adnp_irq_setup(struct adnp *gpio)
> > +{
> > +       unsigned int regs =3D 1 << gpio->reg_shift, i;
> > +       struct gpio_chip *chip =3D &gpio->gpio;
> > +       int err;
> > +
> > +       mutex_init(&gpio->irq_lock);
> > +
> > +       gpio->irq_mask =3D devm_kzalloc(chip->dev, regs * 7, GFP_KERNEL=
);
> > +       if (!gpio->irq_mask)
> > +               return -ENOMEM;
> > +
> > +       gpio->irq_mask_cur =3D gpio->irq_mask + (regs * 1);
> > +       gpio->irq_level =3D gpio->irq_mask + (regs * 2);
> > +       gpio->irq_rise =3D gpio->irq_mask + (regs * 3);
> > +       gpio->irq_fall =3D gpio->irq_mask + (regs * 4);
> > +       gpio->irq_high =3D gpio->irq_mask + (regs * 5);
> > +       gpio->irq_low =3D gpio->irq_mask + (regs * 6);
>=20
> I'm not following this regs * 1, regs * 2 ... regs *7 stuff. What are you=
 doing
> here? Explain with some comment atleast.

Basically I need at least irq_level, irq_rise, irq_fall, irq_high and
irq_low to keep track of the current level and trigger modes for each
interrupt. Instead of allocating small chunks for each of these I
allocate one chunk and just make the others point into that.

> > +
> > +       for (i =3D 0; i < regs; i++) {
> > +               err =3D adnp_read(gpio, GPIO_PLR(gpio) + i, &gpio->irq_=
level[i]);
> > +               if (err < 0)
> > +                       return err;
> > +       }
>=20
> Looks like regmap reimplementation.

This is used to obtain the initial pin levels, which in turn is required
to check for rising and falling edges.

> > +       gpio->domain =3D irq_domain_add_linear(chip->of_node, chip->ngp=
io,
> > +                                            &adnp_irq_domain_ops, gpio=
);
> > +
> > +       err =3D request_threaded_irq(gpio->client->irq, NULL, adnp_irq,
> > +                                  IRQF_TRIGGER_RISING | IRQF_ONESHOT,
> > +                                  dev_name(chip->dev), gpio);
>=20
> Since you're using devm_* above use it here too:
> devm_request_threaded_irq().
>=20
> > +       if (err !=3D 0) {
> > +               dev_err(chip->dev, "can't request IRQ#%d: %d\n",
> > +                       gpio->client->irq, err);
> > +               goto error;
> > +       }
> > +
> > +       gpio->gpio.to_irq =3D adnp_gpio_to_irq;
> > +       return 0;
> > +
> > +error:
> > +       irq_domain_remove(gpio->domain);
> > +       return err;
> > +}
> > +
> > +static void adnp_irq_teardown(struct adnp *gpio)
> > +{
> > +       unsigned int irq, i;
> > +
> > +       free_irq(gpio->client->irq, gpio);
>=20
> If you're using devm to grab the IRQ this is not needed.

I don't think that'll work. In this case the interrupt needs to be freed
before cleaning up, because otherwise the interrupt handler may still be
run after the IRQ domain has already been removed.

>=20
> > +
> > +       for (i =3D 0; i < gpio->gpio.ngpio; i++) {
> > +               irq =3D irq_find_mapping(gpio->domain, i);
> > +               if (irq > 0)
> > +                       irq_dispose_mapping(irq);
> > +       }
> > +
> > +       irq_domain_remove(gpio->domain);
> > +}
> > +
> > +static __devinit int adnp_i2c_probe(struct i2c_client *client,
> > +                                   const struct i2c_device_id *id)
> > +{
> > +       struct adnp *gpio;
> > +       u32 num_gpios;
> > +       int err;
> > +
> > +       err =3D of_property_read_u32(client->dev.of_node, "nr-gpios",
> > +                                  &num_gpios);
> > +       if (err < 0)
> > +               return err;
> > +
> > +       client->irq =3D irq_of_parse_and_map(client->dev.of_node, 0);
> > +       if (client->irq =3D=3D NO_IRQ)
>=20
> Just if (!client->irq) since NO_IRQ is 0 nowadays.

Okay, will do.

>=20
> > +               return -EPROBE_DEFER;
>=20
> Why would you defer in this case? If the IRQ controller appear later
> than the GPIO driver?

Yes. In particular when using DT it can happen that the parent interrupt
controller is probed later than this.

> > +       gpio =3D devm_kzalloc(&client->dev, sizeof(*gpio), GFP_KERNEL);
> > +       if (!gpio)
> > +               return -ENOMEM;
> > +
> > +       mutex_init(&gpio->i2c_lock);
> > +       gpio->client =3D client;
> > +
> > +       err =3D adnp_gpio_setup(gpio, num_gpios);
> > +       if (err < 0)
> > +               return err;
> > +
> > +       if (IS_ENABLED(CONFIG_GPIO_ADNP_IRQ)) {
> > +               err =3D adnp_irq_setup(gpio);
> > +               if (err < 0)
> > +                       goto teardown;
> > +       }
>=20
> And that activates the question why this should be conditional,
> please elaborate.

I think I've answered this before.

> > +       err =3D gpiochip_add(&gpio->gpio);
> > +       if (err < 0)
> > +               goto teardown;
> > +
> > +       i2c_set_clientdata(client, gpio);
> > +       return 0;
> > +
> > +teardown:
> > +       if (IS_ENABLED(CONFIG_GPIO_ADNP_IRQ))
> > +               adnp_irq_teardown(gpio);
>=20
> Here too.
>=20
> > +
> > +       return err;
> > +}
>=20
> Most of the driver looks very good though! The code is
> clean and easy to read and maintain.
>=20
> But we need to iron out the details.

Thanks for reviewing. I'll fixup the problems you've pointed out and
will have to retest.

Thierry

--5QAgd0e35j3NYeGe
Content-Type: application/pgp-signature

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.19 (GNU/Linux)

iQIcBAEBAgAGBQJQFjwCAAoJEN0jrNd/PrOhtywP+wRJEw+0QrWKwqpVuX0GDZO0
FXrTn7qvATkNgRta8KJtqMbclOYdD1sqJoWatbzLhBBsyKVxn7yPf5F1Q4AYKNdh
eh95hVdxngyDcPkCia1DnfToVZMWIFXI6NsF19/zXU4J6paDG6UYvNuA+/JIVdIl
8scQ7bRoUaFl8DoR1f2mDuTsRafyzJLjSiKlTSGl3DrwJ52t76SSQiwhEpIg1wxu
pVHrOEhBxhPPOVP+DdiDijW2vPp2NytXnebIRr0zyKkbDNk1Kw4QYnk3EDsHEGo2
uRl39pPZOq+/eVOhkCNP5P3e4hR7HVWHtTBpsbhLI6hv7K+lWB0herRLVn04nJy5
bRWUe9hyAsloMVNzhe53bNRB/WfarVyfmEmXamlhSyM4iFfMt5DQQv+vKp/hFF5I
6AERpBLmybewU8K2tmuvcyfqDWirv6Zb8WILWeNyI/NZj5ngoZfZSCRVMROzmwBw
iYBT+F2xhKFJFVaWPw8Fg3msN5NOgzC3gD5RpDlYX/6Qt2Krw/43C4gJaisMU7c/
v6da811dJLhUg4b5kt70N+SvFEaoeGuZ4fdiV8BTmk8fGO/axetGm/OiIkqrfPrK
udMIom99azmsmNLfHMI2gS7c+Y8E4HEbpwLCbP0jx3byv4lERehoYJPBYutLXQsY
ak1dtxQ1iI9jBXRMh66K
=PqJi
-----END PGP SIGNATURE-----

--5QAgd0e35j3NYeGe--

--===============5012077910755583720==
Content-Type: text/plain; charset="us-ascii"
MIME-Version: 1.0
Content-Transfer-Encoding: 7bit
Content-Disposition: inline

_______________________________________________
devicetree-discuss mailing list
devicetree-discuss-uLR06cmDAlY/bJ5BZ2RsiQ@public.gmane.org
https://lists.ozlabs.org/listinfo/devicetree-discuss

--===============5012077910755583720==--

